# -*- coding: utf-8 -*-
"""GTZAN_model_test_version_0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1MrL55QVbGLsLRCfGPkHMoRt4F5PjUBXK
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
drive.mount('/content/drive')

# %cd /content/drive/MyDrive
!mkdir -p ModelTesting
# %cd ModelTesting

# Install required libraries
!pip install transformers torch datasets librosa

import torch
from transformers import pipeline, AutoFeatureExtractor, AutoModelForAudioClassification

model_name = "dima806/music_genres_classification"
pipe = pipeline("audio-classification", model=model_name)

feature_extractor = AutoFeatureExtractor.from_pretrained(model_name)
model = AutoModelForAudioClassification.from_pretrained(model_name)

!git clone https://github.com/MTG/mtg-jamendo-dataset

# %cd /content/drive/MyDrive/ModelTesting
!ls
# %cd mtg-jamendo-dataset/scripts

# Install required libraries
!pip install transformers torch datasets librosa
import commons

input_file = '/content/drive/MyDrive/ModelTesting/mtg-jamendo-dataset/data/autotagging.tsv'
tracks, tags, extra = commons.read_file(input_file)

print("Total tracks:", len(tracks))
print("Example track:", list(tracks.items())[0])

genres = ["blues", "classical", "country", "disco", "hiphop", "jazz", "metal", "pop", "reggae", "rock"]

relevant_tracks = {}

for track_id, track_data in tracks.items():
    for genre in track_data["genre"]:
        if genre in genres:
          track_data["track_id"] = track_id
          file_name = track_data["path"]
          relevant_tracks[file_name] = track_data

print("Number of relevant tracks:", len(relevant_tracks))

#!mkdir -p content/mtg-jamendo-moodtheme
#!python3 scripts/download/download.py --dataset autotagging_moodtheme --type audio_low content/mtg-jamendo-moodtheme --unpack --remove

def normalize(genre):
    return genre.lower().replace("-", "").replace(" ", "")

genres = [normalize(g) for g in ["blues", "classical", "country", "disco", "hiphop", "jazz", "metal", "pop", "reggae", "rock"]]

import os

# pick one test file â€” adjust this path as needed
test_folder = "/content/drive/MyDrive/ModelTesting/audio/00"
test_file = "1009600.mp3"

full_path = os.path.join(test_folder, test_file)
rel_path = os.path.join(os.path.basename(test_folder), test_file)

# confirm file exists
if os.path.exists(full_path):
    print("testign on:", full_path)
    predictions = pipe(full_path)
    print("raw predictions:", predictions)

    top_pred = normalize(predictions[0]["label"])
    print("top normalized prediction:", top_pred)

    if rel_path in relevant_tracks:
        relevant_tracks[rel_path]["predictions"] = top_pred
        print("prediction added torelevant_tracks.")

else:
    print("file not found:", full_path)

import os
import pandas as pd

audio_file_path = "/content/drive/MyDrive/ModelTesting/audio"  # Replace with actual file path

for folder in os.listdir(audio_file_path):
    folder_path = os.path.join(audio_file_path, folder)
    # for the weird .tarm2qgcnpv thing??
    if not os.path.isdir(folder_path):
        continue

    for filename in os.listdir(folder_path):
        if not filename.endswith(".mp3"):
            continue

        # Build the relative path like "00/123456.mp3"
        rel_path = os.path.join(folder, filename)

        if rel_path not in relevant_tracks:
            continue

        path = os.path.join(folder_path, filename)
        predictions = pipe(path)
        top_pred = normalize(predictions[0]["label"])
        relevant_tracks[rel_path]["predictions"] = top_pred

correct = {genre: [] for genre in genres}
incorrect = {genre: [] for genre in genres}

for filename, track_data in relevant_tracks.items():
    pred = track_data.get("predictions")
    if not pred:
        continue

    # Normalize all ground truth genres
    true_genres = [normalize(g) for g in track_data["genre"] if normalize(g) in genres]

    if pred in true_genres:
        correct[pred].append(filename)
    else:
        for g in true_genres:
            incorrect[g].append(filename)

incorrect