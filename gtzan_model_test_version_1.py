# -*- coding: utf-8 -*-
"""GTZAN_model_test_version_1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11lkUTlunnDlErBFlyxhNzIqRfpMCq_Sv
"""

# Commented out IPython magic to ensure Python compatibility.
from google.colab import drive
import os
import sys

drive.mount('/content/drive')

# %cd /content/drive/MyDrive
!mkdir -p ModelTesting
# %cd ModelTesting

# Install required libraries
!pip install transformers torch datasets librosa

import torch
from transformers import pipeline, AutoFeatureExtractor, AutoModelForAudioClassification

model_name = "dima806/music_genres_classification"
pipe = pipeline("audio-classification", model=model_name)

feature_extractor = AutoFeatureExtractor.from_pretrained(model_name)
model = AutoModelForAudioClassification.from_pretrained(model_name)

!git clone https://github.com/MTG/mtg-jamendo-dataset

# %cd /content/drive/MyDrive/ModelTesting
!ls
# %cd mtg-jamendo-dataset/scripts

# Add the current directory to the Python path to allow importing local modules
sys.path.insert(0, os.getcwd())

# Install required libraries
!pip install transformers torch datasets librosa
import commons

input_file = '/content/drive/MyDrive/ModelTesting/mtg-jamendo-dataset/data/autotagging.tsv'
tracks, tags, extra = commons.read_file(input_file)

print("Total tracks:", len(tracks))
print("Example track:", list(tracks.items())[0])

genres = ["blues", "classical", "country", "disco", "hiphop", "jazz", "metal", "pop", "reggae", "rock"]

relevant_tracks = {}

for track_id, track_data in tracks.items():
    for genre in track_data["genre"]:
        if genre in genres:
          track_data["track_id"] = track_id
          file_name = track_data["path"]
          relevant_tracks[file_name] = track_data

print("Number of relevant tracks:", len(relevant_tracks))

import os

genres = ["blues", "classical", "country", "disco", "hiphop", "jazz", "metal", "pop", "reggae", "rock"]

relevant_tracks = {}
data_dir = '/content/drive/MyDrive/ModelTesting/audio'  # adjust if needed

for track_id, track_data in tracks.items():
    keep = False
    for genre in track_data["genre"]:
        if genre in genres:
            keep = True
            track_data["track_id"] = track_id
            file_name = track_data["path"]
            relevant_tracks[file_name] = track_data
            break  # no need to check other genres

    if not keep:
        # Delete irrelevant file
        file_path = os.path.join(data_dir, track_data["path"])
        if os.path.exists(file_path):
            os.remove(file_path)

print("Number of relevant tracks:", len(relevant_tracks))

#!mkdir -p content/mtg-jamendo-moodtheme
#!python3 scripts/download/download.py --dataset autotagging_moodtheme --type audio_low content/mtg-jamendo-moodtheme --unpack --remove

def normalize(genre):
    return genre.lower().replace("-", "").replace(" ", "")

genres = [normalize(g) for g in ["blues", "classical", "country", "disco", "hiphop", "jazz", "metal", "pop", "reggae", "rock"]]

import os

base_dir = '/content/drive/MyDrive/ModelTesting/audio'

audio_files = []

for folder in os.listdir(base_dir):
    folder_path = os.path.join(base_dir, folder)
    if os.path.isdir(folder_path):
        # add all audio files from this folder
        audio_files.extend([os.path.join(folder, f)
                            for f in os.listdir(folder_path)
                            if f.endswith((".wav", ".mp3", ".flac"))])

print("Total number of audio files:", len(audio_files))

import os
from tqdm import tqdm

audio_file_path = "/content/drive/MyDrive/ModelTesting/audio"
output_txt = "/content/drive/MyDrive/ModelTesting/final_results.txt"

# Define normalize again (in case itâ€™s not loaded)
def normalize(genre):
    return genre.lower().replace("-", "").replace(" ", "")

# Define target genres
genres = [normalize(g) for g in [
    "blues", "classical", "country", "disco", "hiphop",
    "jazz", "metal", "pop", "reggae", "rock"
]]

# open file in append mode, so if it crashes mid-way, existing data stays
with open(output_txt, "a", encoding="utf-8") as f:
    f.write("TRACK|TRUE GENRES|PREDICTION")

    # loop over relevant_tracks only
    for rel_path, data in tqdm(relevant_tracks.items(), desc="Running predictions"):
        if "predictions" in data:
            print("here")
            continue  # skip already predicted

        # get full path from relative one
        parts = rel_path.split("/")
        if len(parts) < 2:
            continue
        folder, filename = parts[0], parts[1]
        full_path = os.path.join(audio_file_path, folder, filename)

        # skip missing files
        if not os.path.exists(full_path):
            continue

        try:
            preds = pipe(full_path)
            top_pred = normalize(preds[0]["label"])
            data["predictions"] = top_pred  # update dict in case you want it later
        except Exception as e:
            top_pred = "error"
            print("âš ï¸ Error on", rel_path, ":", e)

        # get true genres
        true_genres = [normalize(g) for g in data.get("genre", []) if normalize(g) in genres]

        # write immediately to file (so progress survives)
        f.write(f"{rel_path}|{', '.join(true_genres)}|{top_pred}\n")
        f.flush()  # ðŸ’¾ ensure write is saved immediately

print(f"\nâœ… All results (so far) saved live to: {output_txt}")